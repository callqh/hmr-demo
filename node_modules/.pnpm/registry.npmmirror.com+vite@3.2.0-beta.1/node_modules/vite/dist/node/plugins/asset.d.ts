/// <reference types="node" />
import { Buffer } from 'node:buffer';
import type { NormalizedOutputOptions, OutputAsset, OutputOptions, PluginContext, PreRenderedAsset, RenderedChunk } from 'rollup';
import MagicString from 'magic-string';
import type { Plugin } from '../plugin';
import type { ResolvedConfig } from '../config';
export declare const assetUrlRE: RegExp;
export declare const duplicateAssets: WeakMap<Readonly<Omit<import("../config").UserConfig, "plugins" | "assetsInclude" | "optimizeDeps" | "worker"> & {
    configFile: string | undefined;
    configFileDependencies: string[];
    inlineConfig: import("../config").InlineConfig;
    root: string;
    base: string;
    publicDir: string;
    cacheDir: string;
    command: "build" | "serve";
    mode: string;
    isWorker: boolean;
    mainConfig: Readonly<Omit<import("../config").UserConfig, "plugins" | "assetsInclude" | "optimizeDeps" | "worker"> & any & import("../config").PluginHookUtils> | null;
    isProduction: boolean;
    env: Record<string, any>;
    resolve: Required<import("./resolve").ResolveOptions> & {
        alias: import("dep-types/alias").Alias[];
    };
    plugins: readonly Plugin[];
    server: import("..").ResolvedServerOptions;
    build: import("../build").ResolvedBuildOptions;
    preview: import("..").ResolvedPreviewOptions;
    ssr: import("..").ResolvedSSROptions;
    assetsInclude: (file: string) => boolean;
    logger: import("..").Logger;
    createResolver: (options?: Partial<import("./resolve").InternalResolveOptions> | undefined) => import("../config").ResolveFn;
    optimizeDeps: import("..").DepOptimizationOptions;
    packageCache: import("..").PackageCache;
    worker: import("../config").ResolveWorkerOptions;
    appType: import("../config").AppType;
    experimental: import("../config").ExperimentalOptions;
} & import("../config").PluginHookUtils>, Map<string, OutputAsset>>;
export declare function registerCustomMime(): void;
export declare function renderAssetUrlInJS(ctx: PluginContext, config: ResolvedConfig, chunk: RenderedChunk, opts: NormalizedOutputOptions, code: string): MagicString | undefined;
/**
 * Also supports loading plain strings with import text from './foo.txt?raw'
 */
export declare function assetPlugin(config: ResolvedConfig): Plugin;
export declare function checkPublicFile(url: string, { publicDir }: ResolvedConfig): string | undefined;
export declare function fileToUrl(id: string, config: ResolvedConfig, ctx: PluginContext): Promise<string>;
export declare function getAssetFilename(hash: string, config: ResolvedConfig): string | undefined;
export declare function getPublicAssetFilename(hash: string, config: ResolvedConfig): string | undefined;
export declare function resolveAssetFileNames(config: ResolvedConfig): string | ((chunkInfo: PreRenderedAsset) => string);
/**
 * converts the source filepath of the asset to the output filename based on the assetFileNames option. \
 * this function imitates the behavior of rollup.js. \
 * https://rollupjs.org/guide/en/#outputassetfilenames
 *
 * @example
 * ```ts
 * const content = Buffer.from('text');
 * const fileName = assetFileNamesToFileName(
 *   'assets/[name].[hash][extname]',
 *   '/path/to/file.txt',
 *   getHash(content),
 *   content
 * )
 * // fileName: 'assets/file.982d9e3e.txt'
 * ```
 *
 * @param assetFileNames filename pattern. e.g. `'assets/[name].[hash][extname]'`
 * @param file filepath of the asset
 * @param contentHash hash of the asset. used for `'[hash]'` placeholder
 * @param content content of the asset. passed to `assetFileNames` if `assetFileNames` is a function
 * @returns output filename
 */
export declare function assetFileNamesToFileName(assetFileNames: Exclude<OutputOptions['assetFileNames'], undefined>, file: string, contentHash: string, content: string | Buffer): string;
export declare const publicAssetUrlCache: WeakMap<Readonly<Omit<import("../config").UserConfig, "plugins" | "assetsInclude" | "optimizeDeps" | "worker"> & {
    configFile: string | undefined;
    configFileDependencies: string[];
    inlineConfig: import("../config").InlineConfig;
    root: string;
    base: string;
    publicDir: string;
    cacheDir: string;
    command: "build" | "serve";
    mode: string;
    isWorker: boolean;
    mainConfig: Readonly<Omit<import("../config").UserConfig, "plugins" | "assetsInclude" | "optimizeDeps" | "worker"> & any & import("../config").PluginHookUtils> | null;
    isProduction: boolean;
    env: Record<string, any>;
    resolve: Required<import("./resolve").ResolveOptions> & {
        alias: import("dep-types/alias").Alias[];
    };
    plugins: readonly Plugin[];
    server: import("..").ResolvedServerOptions;
    build: import("../build").ResolvedBuildOptions;
    preview: import("..").ResolvedPreviewOptions;
    ssr: import("..").ResolvedSSROptions;
    assetsInclude: (file: string) => boolean;
    logger: import("..").Logger;
    createResolver: (options?: Partial<import("./resolve").InternalResolveOptions> | undefined) => import("../config").ResolveFn;
    optimizeDeps: import("..").DepOptimizationOptions;
    packageCache: import("..").PackageCache;
    worker: import("../config").ResolveWorkerOptions;
    appType: import("../config").AppType;
    experimental: import("../config").ExperimentalOptions;
} & import("../config").PluginHookUtils>, Map<string, string>>;
export declare const publicAssetUrlRE: RegExp;
export declare function publicFileToBuiltUrl(url: string, config: ResolvedConfig): string;
export declare function urlToBuiltUrl(url: string, importer: string, config: ResolvedConfig, pluginContext: PluginContext): Promise<string>;
